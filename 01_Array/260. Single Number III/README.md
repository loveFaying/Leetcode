### main.cpp
- 自己写的方法，勉强AC
### main2.cpp
- 重构代码，减少代码量
- 使用哈希表统计数组中每一个元素出现的次数；统计完成后 遍历哈希表，将所有只出现一次的数放入答案中。
### main3.cpp
- 采用异或的方法
- 大体思路： 假设最终的结果是res1和res2
```
1. 因为 a = b ^ b ^ a , 所以把nums中的所有元素异或起来，这样出现两次的元素就会抵消掉，最终得到 (res1 ^ res2)
2. 使用位运算 (res1 ^ res2) & -(res1 ^ res2) 将 (res1 ^ res2) 中低位的1取出来，这样res1和res2中对应位置必定是一个为1，一个为0.
3. 最后，遍历nums，将对应位置为1的划分成一类，对应位置为0的划分成一类，这两类分别进行异或操作，得到的最终解是res1 和 res2.
```
- & | ^ 操作
```
A = 0011 1100   
B = 0000 1101
A&B = 0000 1100  (都为1则为1，其余情况为0)
A|B = 0011 1101  (有一个为1，就是1)
A^B = 0011 0001  (相同为0，不同为1)
```
- 负数的二进制码计算方法
```
3 ： 0000 0011
-3： 1111 1101 (按位取反 + 1)
```
-  C++ 中 整数的上下限 INT_MIN  INT_MAX      limits.h
```
因为int 4字节，32位
INT_MAX = 2^31-1
INT_MIN = -2^31

以8位为例：(第一位是符号)
0000 0000 —— 0111 1111 ： 0 —— +127
1000 0001 —— 1111 1111 ： -1 —— -127
1000 0000 : -128 

INT_MIN 与 INT_MAX 不遵循数学计算规则
INT_MAX + 1 = INT_MIN
INT_MIN - 1 = INT_MAX
INT_MAX + 1 < INT_MAX
INT_MIN - 1 > INT_MIN
abs(INT_MIN) = INT_MIN
abs(INT_MIN) < 0
```
- x & (-x) 操作
```
x & (-x) == x & (~x+1)
用于计算某个二进制数的最低位

x = 5
0101 & 1011 = 0001
x = 8
0001000 & 1111000 = 0001000

```
- 防止溢出？
```
官方解上说是防止溢出
int nums[] = {1,1,0, -2147483648};

int lsb = ( xorsum == INT_MIN ? xorsum : xorsum & (-xorsum) );
int lsb = xorsum & (-xorsum);

但是，用这俩方法本地上都能得到正确的答案，提交的时候会出现问题，不知道为啥。
```
